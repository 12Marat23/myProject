# ==========================================================================================================================
# Find the first non-consecutive number
# =========================================================================================================================

''' Ваша задача - найти первый элемент массива, который не является последовательным.
Под "не последовательным" мы подразумеваем, что он не ровно на 1 больше предыдущего элемента массива.
Например. Если у нас есть массив [1,2,3,4,6,7,8], то 1, затем 2, затем 3, затем 4 все являются последовательными,
но 6 - нет, так что это первое непоследовательное число.
Если весь массив является последовательным, то верните null2.

Массив всегда будет содержать по крайней мере 2 элемента1, и все элементы будут числами.
Все номера также будут уникальными и расположены в порядке возрастания.
Числа могут быть положительными или отрицательными, и первое не последовательное тоже может быть любым из них!
'''

# import codewars_test as test

# def first_non_consecutive(arr):
#     #your code here
#     for i, v in enumerate(arr, arr[0]):
#         if v != i:
#             return v


# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(first_non_consecutive([1,2,3,4,6,7,8]), 6)
#         test.assert_equals(first_non_consecutive([1,2,3,4,5,6,7,8]), None)
#         test.assert_equals(first_non_consecutive([4,6,7,8,9,11]), 6)
#         test.assert_equals(first_non_consecutive([4,5,6,7,8,9,11]), 11)
#         test.assert_equals(first_non_consecutive([31,32]), None)
#         test.assert_equals(first_non_consecutive([-3,-2,0,1]), 0)
#         test.assert_equals(first_non_consecutive([-5,-4,-3,-1]), -1)

# =========================================================================================================================

# ==========================================================================================================================
# Remove duplicates from list
# =========================================================================================================================
'''Определите функцию, которая удаляет дубликаты из массива чисел и возвращает его в результате.
Порядок следования должен оставаться прежним.'''
# import codewars_test as test


# def distinct(seq):
# x=[]
# for i in seq:
#     if i not in x:
#         x.append(i)
# return x
'''Варианты решения:
return list(dict.fromkeys(seq))
'''

# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(distinct([1]), [1])
#         test.assert_equals(distinct([1, 2]), [1, 2])
#         test.assert_equals(distinct([1, 1, 2]), [1, 2])
#         test.assert_equals(distinct([1, 1, 1, 2, 3, 4, 5]), [1, 2, 3, 4, 5])
#         test.assert_equals(distinct([1, 2, 2, 3, 3, 4, 4, 5, 6, 7, 7, 7]), [1, 2, 3, 4, 5, 6, 7])
#         test.assert_equals(
#             distinct([1181476, 4332812, 1181476, 1181476, 4332812, 4332812, 3318909, 1181476, 3318909, 4799846, 1181476,
#                       3644004, 4332812, 3318909, 1181476, 4799846, 1181476, 3318909, 4799846, 4079619, 4332812, 3318909,
#                       1181476, 4799846, 4079619, 3644004, 4799846, 4079619, 4799846, 1181476, 3318909, 4332812, 1181476,
#                       3644004, 3318909, 4799846, 1181476, 4799846, 4332812, 4799846, 4079619, 3644004, 4799846, 3644004,
#                       4332812, 3318909, 1181476, 3318909, 4799846, 4799846, 3318909, 3318909, 4799846, 4799846, 4332812,
#                       3644004, 3644004, 4799846, 3318909, 4799846, 3318909, 1181476, 3318909, 4332812, 3644004, 4332812,
#                       4799846, 3318909, 3318909, 4332812, 4799846, 4079619, 4332812, 3318909, 4799846, 4332812, 4332812,
#                       1181476, 3644004, 3318909, 4332812, 4332812, 1181476, 1181476, 3318909, 3644004, 1181476, 3318909,
#                       4332812, 4799846, 4332812, 1181476, 3318909, 4332812, 4079619, 4332812, 3318909, 4799846, 3644004,
#                       4799846, 3644004, 4799846, 4332812, 3318909, 4799846, 3318909, 4799846, 1181476, 4332812, 1181476,
#                       4799846, 4079619, 1181476, 4799846, 1181476, 4332812, 3318909, 1181476, 3644004, 4799846, 4079619,
#                       3318909, 1181476, 3644004, 4332812, 3318909, 4332812, 3318909, 3318909, 1181476, 1181476, 1181476,
#                       3644004, 3318909, 3318909, 3318909, 4332812, 4332812, 3318909, 3644004, 4332812, 4332812, 1181476,
#                       4799846, 4799846, 4079619, 1181476, 3644004, 4799846, 4332812, 1181476, 4799846, 4332812, 4332812,
#                       4332812, 1181476, 4332812, 4332812, 4799846, 3644004, 4079619, 4799846, 4799846, 3318909, 4799846,
#                       3644004, 3318909, 4799846, 3318909, 3318909, 4799846, 1181476, 3318909, 4079619, 3644004, 3644004,
#                       1181476, 3318909, 3318909, 4332812, 1181476, 4079619, 4332812, 3318909, 4079619, 3318909, 4332812,
#                       4079619, 4799846, 4799846, 4332812, 3644004, 4332812, 1181476, 4799846, 3318909, 3318909, 3318909,
#                       4799846, 4332812, 4079619, 1181476, 3318909, 3318909, 4799846, 4332812, 1181476, 4332812, 4332812,
#                       1181476, 4799846, 3318909, 4332812, 4332812, 4799846, 4332812, 4332812, 3318909, 3318909]),
#             [1181476, 4332812, 3318909, 4799846, 3644004, 4079619])

# =========================================================================================================================

# ==========================================================================================================================
# Remove duplicates from list
# =========================================================================================================================
'''Лягушка с широким ртом особенно интересуется пищевыми привычками других существ.
Он просто не может перестать спрашивать встречающихся ему существ, что они любят есть. 
Но потом он встречает аллигатора, который просто обожает есть лягушек с широким ртом!

Когда он встречает аллигатора, тот делает крошечный ротик.
Ваша цель в этом ката - создать полный метод mouth_size этот метод принимает один аргумент animal, 
который соответствует животному, с которым столкнулась лягушка. Если это аллигатор (без учета регистра), 
верните значение small, в противном случае верните значение wide.'''

# import codewars_test as test


# def mouth_size(animal):
#         # code here
#     return "small" if animal.lower() == "alligator" else "wide"

# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(mouth_size("toucan"), "wide")
#         test.assert_equals(mouth_size("ant bear"), "wide")
#         test.assert_equals(mouth_size("alligator"), "small")
# =========================================================================================================================

# ==========================================================================================================================
# Simple Fun #1: Seats in Theater
# =========================================================================================================================
'''Главная проблема - ваша застенчивость: вы боитесь, что в конечном итоге закроете обзор 
(пусть даже всего на пару секунд) всем людям, которые сидят позади вас и в вашей колонне или колоннах слева от вас. 
Чтобы набраться смелости, вы решаете подсчитать количество таких людей и посмотреть, сможете ли вы добраться до выхода, 
не потревожив слишком много людей.

Учитывая общее количество рядов и столбцов в кинотеатре (nRows и nCols соответственно), 
а также ряд и столбец, в которых вы сидите, верните количество людей, которые сидят строго позади вас
 и в вашей колонке или слева, предполагая, что все места заняты.

Пример
Для nCols = 16, nRows = 11, col = 5 и row = 3 выходные данные должны быть
'''
# import codewars_test as test


# def seats_in_theater(tot_cols, tot_rows, col, row):
#     # your code here
#     return (tot_cols - (col - 1)) * (tot_rows - row)


# @test.describe("Basic tests")
# def fxd():
#     @test.it('')
#     def check():
#         test.assert_equals(seats_in_theater(16, 11, 5, 3), 96)
#         test.assert_equals(seats_in_theater(1, 1, 1, 1), 0)
#         test.assert_equals(seats_in_theater(13, 6, 8, 3), 18)
#         test.assert_equals(seats_in_theater(60, 100, 60, 1), 99)
#         test.assert_equals(seats_in_theater(1000, 1000, 1000, 1000), 0)
# =========================================================================================================================

# ==========================================================================================================================
# Simple Fun #1: Seats in Theater
# =========================================================================================================================

'''Вам дан массив с положительными числами и неотрицательным числом N. 
Вы должны найти N-ю степень элемента в массиве с индексом N. 
Если N находится за пределами массива, то верните значение -1. Не забывайте, что первый элемент имеет индекс 0.

Давайте рассмотрим несколько примеров:

массив = [1, 2, 3, 4] и N = 2, тогда результат равен 3 ^ 2 == 9;
array = [1, 2, 3] и N = 3, но N находится за пределами массива, поэтому результат равен -1.'''

# import codewars_test as test


# def index(array, n):
#     return array[n]**n if n < len(array) else -1


# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(index([1, 2, 3, 4], 2), 9)
#         test.assert_equals(index([5, 6], 0), 1)
#         test.assert_equals(index([1, 3, 10, 100], 3), 1000000)
#         test.assert_equals(index([14, 13, 14, 20, 18], 10), -1)
#         test.assert_equals(index([18, 10, 0, 15, 17, 20, 3, 4], 8), -1)

# =========================================================================================================================

# ==========================================================================================================================
# Array plus array
# =========================================================================================================================

'''Я новичок в кодировании, и теперь я хочу получить сумму двух массивов...
 Фактически сумма всех их элементов. Я буду признателен вам за помощь.

P.S. Каждый массив содержит только целые числа. Вывод тоже представляет собой число.'''

# import codewars_test as test


# def array_plus_array(arr1, arr2):
#     return sum(arr1)+sum(arr2)


# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(array_plus_array([1, 2, 3], [4, 5, 6]), 21)
#         test.assert_equals(array_plus_array([-1, -2, -3], [-4, -5, -6]), -21)
#         test.assert_equals(array_plus_array([0, 0, 0], [4, 5, 6]), 15)
#         test.assert_equals(array_plus_array([100, 200, 300], [400, 500, 600]), 2100)

# =========================================================================================================================

# ==========================================================================================================================
# Grasshopper - Personalized Message
# =========================================================================================================================

'''Создайте функцию, которая выдает персонализированное приветствие. 
Эта функция принимает два параметра: имя и владельца.
Используйте условные обозначения для возврата правильного сообщения:'''

# import codewars_test as test
# def greet(name, owner):
#     # Add code here
#       return 'Hello boss' if name == owner else 'Hello guest'
'''Вариант решения:
return 'Hello ' + ['guest', 'boss'][name == owner]
'''

# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(greet('Daniel', 'Daniel'), 'Hello boss')
#         test.assert_equals(greet('Greg', 'Daniel'), 'Hello guest')

# =========================================================================================================================

# ==========================================================================================================================
# Transportation on vacation
# =========================================================================================================================
'''Каждый день аренды автомобиля обходится вам в 40 долларов. 
Если вы арендуете автомобиль на 7 или более дней, вы получаете 50 долларов от общей суммы. 
В качестве альтернативы, если вы арендуете автомобиль на 3 или более дней, вы получаете 20 долларов от общей суммы.

Напишите код, который выдает общую сумму за разные дни(d).'''


# import codewars_test as test


def rental_car_cost(d):
    # your code
    # return d * 40 - 50 if d >= 7 else d * 40 - 20 if d >= 3 else d*40
    return d * 40 - (d > 2) * 20 - (d > 6) * 30


# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(rental_car_cost(1), 40)
#         test.assert_equals(rental_car_cost(4), 140)
#         test.assert_equals(rental_car_cost(7), 230)
#         test.assert_equals(rental_car_cost(8), 270)
#         test.assert_equals(rental_car_cost(2), 80)

# =========================================================================================================================

# ==========================================================================================================================
# Do I get a bonus?
# =========================================================================================================================

# import codewars_test as test
# def bonus_time(salary, bonus):
#     #your code here
#     return f'${salary*10}' if bonus else f'${salary}'
'''Варианты решения:
*   return "${}".format(salary * (10 if bonus else 1))

*   return f"${salary * 10 if bonus else salary}"
'''
# @test.describe("Fixed Tests")
# def basic_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(bonus_time(10000, True), '$100000')
#         test.assert_equals(bonus_time(25000, True), '$250000')
#         test.assert_equals(bonus_time(10000, False), '$10000')
#         test.assert_equals(bonus_time(60000, False), '$60000')
#         test.assert_equals(bonus_time(2, True), '$20')
#         test.assert_equals(bonus_time(78, False), '$78')
#         test.assert_equals(bonus_time(67890, True), '$678900')

# =========================================================================================================================

# ==========================================================================================================================
# Get Planet Name By ID
# =========================================================================================================================


# import codewars_test as test

# def get_planet_name(id):
# This doesn't work; Fix it!
# name = {
#      1: "Mercury",
#      2: "Venus",
#      3: "Earth",
#      4: "Mars",
#      5: "Jupiter",
#      6: "Saturn",
#      7: "Uranus",
#      8: "Neptune",
# }
# return name[id]
'''
Варианты решения:
 return{
        1: "Mercury",
        2: "Venus",
        3: "Earth",
        4: "Mars",
        5: "Jupiter",
        6: "Saturn",
        7: "Uranus",
        8: "Neptune",
    }.get(id)
'''

# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(get_planet_name(2), 'Venus')
#         test.assert_equals(get_planet_name(5), 'Jupiter')
#         test.assert_equals(get_planet_name(3), 'Earth')
#         test.assert_equals(get_planet_name(4), 'Mars')
#         test.assert_equals(get_planet_name(8), 'Neptune')
#         test.assert_equals(get_planet_name(1), 'Mercury')

# =========================================================================================================================

# ==========================================================================================================================
# Grasshopper - Check for factor
# =========================================================================================================================

'''Эта функция должна проверить, является ли коэффициент коэффициентом базы.
Возвращает true, если это фактор, или false, если это не так.'''

# import codewars_test as test


# def check_for_factor(base, factor):
#     # your code here
#     return base % factor == 0


# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it("Should return True")
#     def should_return_true():
#         test.assert_equals(check_for_factor(10, 2), True)
#         test.assert_equals(check_for_factor(63, 7), True)
#         test.assert_equals(check_for_factor(2450, 5), True)
#         test.assert_equals(check_for_factor(24612, 3), True)
#
#     @test.it("Should return False")
#     def should_return_false():
#         test.assert_equals(check_for_factor(9, 2), False)
#         test.assert_equals(check_for_factor(653, 7), False)
#         test.assert_equals(check_for_factor(2453, 5), False)
#         test.assert_equals(check_for_factor(24617, 3), False)

# =========================================================================================================================

# ==========================================================================================================================
# For Twins: 1. Types
# =========================================================================================================================
'''Напишите функцию, которая будет принимать два параметра: переменную и тип, и проверьте, 
соответствует ли тип переменной типу. 
Возвращает true, если типы совпадают, или false, если нет.'''

# import codewars_test as test


# def type_validation(variable, _type):
#     # your code here
#     return type(variable).__name__ == _type


# @test.describe('Example Tests')
# def example_tests():
#     test.assert_equals(type_validation(42, "int"), True)
#     test.assert_equals(type_validation("42", "int"), False)

# =========================================================================================================================

# ==========================================================================================================================
# Exclamation marks series #1: Remove an exclamation mark from the end of string
# =========================================================================================================================

'''Удалите восклицательный знак из конца строки. 
Для начинающего ката вы можете предположить, 
что входные данные всегда представляют собой строку, проверять это не нужно.'''

# import codewars_test as test

# def remove(s):
# return s if s == "" else s[:-1] if list(s)[-1] == '!' else s

'''Варианты решения:
* return s[:-1] if s.endswith('!') else s

* return s.removesuffix('!')
'''

# test.describe("Basic Tests")

# tests = [
#     # [input, [expected]],
#     ["Hi!", "Hi"],
#     ["Hi!!!", "Hi!!"],
#     ["!Hi", "!Hi"],
#     ["!Hi!", "!Hi"],
#     ["Hi! Hi!", "Hi! Hi"],
#     ["Hi", "Hi"],
#     ["!", ""],
#     ["", ""],
# ]

# for inp, exp in tests:
#     test.assert_equals(remove(inp), exp)

# =========================================================================================================================

# ==========================================================================================================================
# Opposite number
# =========================================================================================================================

# import codewars_test as test


# def opposite(number):
#     # your solution here
# return -number if number > 0 else abs(number) if number < 0 else 0

'''Варианты решения:
return -number
'''

# @test.describe("Fixed Tests")
# def basic_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(opposite(1), -1)
#         test.assert_equals(opposite(25.6), -25.6)
#         test.assert_equals(opposite(0), 0)
#         test.assert_equals(opposite(1425.2222), -1425.2222)
#         test.assert_equals(opposite(-3.1458), 3.1458)
#         test.assert_equals(opposite(-95858588225), 95858588225)

# =========================================================================================================================

# ==========================================================================================================================
# Count by X
# =========================================================================================================================

'''ЯНДЕКС ПЕРЕВОДЧИК
Создайте функцию с двумя аргументами, которая вернет массив из первых n кратных x.
Предположим, что и заданное число, и количество раз для подсчета будут положительными числами, большими 0.
Возвращает результаты в виде массива или списка ( в зависимости от языка ).'''

# import codewars_test as test


# def count_by(x, n):
"""
Return a sequence of numbers counting by `x` `n` times.
"""
# return [i for i in range(x, x*n+1, x)]


# @test.describe("Fixed Tests")
# def basic_tests():
#     @test.it("Fixed tests")
#     def fixed_tests():
#         test.assert_equals(count_by(1, 5), [1, 2, 3, 4, 5])
#         test.assert_equals(count_by(2, 5), [2, 4, 6, 8, 10])
#         test.assert_equals(count_by(3, 5), [3, 6, 9, 12, 15])
#         test.assert_equals(count_by(50, 5), [50, 100, 150, 200, 250])
#         test.assert_equals(count_by(100, 5), [100, 200, 300, 400, 500])

# =========================================================================================================================

# ==========================================================================================================================
# Square(n) Sum
# =========================================================================================================================

'''Завершите функцию квадратной суммы так, чтобы она возводила в квадрат каждое переданное в нее число,
 а затем суммировала результаты вместе.

Например, для [1, 2, 2] он должен возвращать 9, потому что 1^2 + 2^2 + 2^2 = 9
'''

# import codewars_test as test


# def square_sum(numbers):
#     # your code here
#     return sum(i ** 2 for i in numbers)


# @test.describe("Fixed Tests")
# def basic_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(square_sum([1, 2]), 5)
#         test.assert_equals(square_sum([0, 3, 4, 5]), 50)
#         test.assert_equals(square_sum([]), 0)
#         test.assert_equals(square_sum([-1, -2]), 5)
#         test.assert_equals(square_sum([-1, 0, 1]), 2)

# =========================================================================================================================

# ==========================================================================================================================
# Convert a string to an array
# =========================================================================================================================

# import codewars_test as test

# def string_to_array(s):
#     # your code here
#     return s.split(' ')

# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(string_to_array("Robin Singh"), ["Robin", "Singh"])
#         test.assert_equals(string_to_array("CodeWars"), ["CodeWars"])
#         test.assert_equals(string_to_array("I love arrays they are my favorite"), ["I", "love", "arrays", "they", "are", "my", "favorite"])
#         test.assert_equals(string_to_array("1 2 3"), ["1", "2", "3"])
#         test.assert_equals(string_to_array(""), [""])

# =========================================================================================================================

# ==========================================================================================================================
# Bin to Decimal
# =========================================================================================================================

'''Завершите функцию, которая преобразует двоичное число (заданное в виде строки) в десятичное число.'''
# import codewars_test as test


# def bin_to_decimal(inp):
#     return int(inp, base=2)


# test.assert_equals(bin_to_decimal("0"), 0)
# test.assert_equals(bin_to_decimal("1"), 1)
# test.assert_equals(bin_to_decimal("10"), 2)
# test.assert_equals(bin_to_decimal("11"), 3)
# test.assert_equals(bin_to_decimal("101010"), 42)
# test.assert_equals(bin_to_decimal("1001001"), 73)

# =========================================================================================================================

# ==========================================================================================================================
# Bin to Decimal
# =========================================================================================================================
'''Завершите функцию, которая принимает два целых числа (a, b, где a < b)
 и возвращает массив всех целых чисел между входными параметрами, включая их.'''

# import codewars_test as test


# def between(a, b):
#     # good luck
#     return [i for i in range(a, b+1)]


# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(between(1, 4), [1, 2, 3, 4])
#         test.assert_equals(between(-2, 2), [-2, -1, 0, 1, 2])

# =========================================================================================================================

# ==========================================================================================================================
# Convert number to reversed array of digits
# =========================================================================================================================

'''Учитывая случайное неотрицательное число, вы должны вернуть цифры этого числа в массиве в обратном порядке.'''

# import codewars_test as test


# def digitize(n):
#     return [int(i) for i in reversed(str(n))]
'''Вариант решения:
    return map(int, str(n)[::-1])
'''

# @test.describe("Fixed Tests")
# def basic_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(digitize(35231), [1, 3, 2, 5, 3])
#         test.assert_equals(digitize(0), [0])
#         test.assert_equals(digitize(23582357), [7, 5, 3, 2, 8, 5, 3, 2])
#         test.assert_equals(digitize(984764738), [8, 3, 7, 4, 6, 7, 4, 8, 9])
#         test.assert_equals(digitize(45762893920), [0, 2, 9, 3, 9, 8, 2, 6, 7, 5, 4])
#         test.assert_equals(digitize(548702838394), [4, 9, 3, 8, 3, 8, 2, 0, 7, 8, 4, 5])

# =========================================================================================================================

# ==========================================================================================================================
# Find numbers which are divisible by given number
# =========================================================================================================================

'''Завершите функцию, которая принимает два аргумента и возвращает все числа, которые делятся на данный делитель.
 Первый аргумент - это массив чисел, а второй - делитель.'''

# import codewars_test as test


# def divisible_by(numbers, divisor):
#     return [i for i in numbers if i % divisor == 0]


# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(divisible_by([1, 2, 3, 4, 5, 6], 2), [2, 4, 6])
#         test.assert_equals(divisible_by([1, 2, 3, 4, 5, 6], 3), [3, 6])
#         test.assert_equals(divisible_by([0, 1, 2, 3, 4, 5, 6], 4), [0, 4])
#         test.assert_equals(divisible_by([0], 4), [0])
#         test.assert_equals(divisible_by([1, 3, 5], 2), [])
#         test.assert_equals(divisible_by([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# =========================================================================================================================

# ==========================================================================================================================
# Short Long Short
# =========================================================================================================================
'''Учитывая 2 строки, a и b, верните строку вида short+long+short, 
с более короткой строкой снаружи и более длинной строкой внутри. 
Строки не будут одинаковой длины, но они могут быть пустыми (нулевая длина ).

Подсказка для пользователей R:
("1", "22") --> "1221"
("22", "1") --> "1221"
'''

# import codewars_test as test


# def solution(a, b):

# return f'{a}{b}{a}'if len(a)<len(b) else f'{b}{a}{b}'
'''Вариант решения:
    short, long = sorted((a, b), key=len)
    return short + long + short
'''

# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(solution('45', '1'), '1451')
#         test.assert_equals(solution('13', '200'), '1320013')
#         test.assert_equals(solution('Soon', 'Me'), 'MeSoonMe')
#         test.assert_equals(solution('U', 'False'), 'UFalseU')

# =========================================================================================================================

# ==========================================================================================================================
# Take the Derivative
# =========================================================================================================================
'''Эта функция принимает в качестве параметров два числа, 
первое из которых является коэффициентом, а второе - показателем степени.

Ваша функция должна умножить эти два числа, 
а затем вычесть 1 из показателя степени. 
Затем он должен вернуть выражение (например, 28x ^ 7). "^ 1" не следует усекать, 
когда показатель степени = 2.

Например:
derive(7, 8)
В этом случае функция должна умножить 7 и 8, а затем вычесть 1 из 8. 
Он должен вывести "56x ^ 7", причем первое число 56 является произведением двух чисел, 
а второе число является показателем степени минус 1.

derive(7, 8) --> this should output "56x^7" 
derive(5, 9) --> this should output "45x^8" 

Результатом работы этой функции должна быть строка
Показатель степени никогда не будет равен 1, и ни одно из чисел никогда не будет равно 0
'''

# def derive(coefficient, exponent):
#     # your code here
#     return f'{coefficient * exponent}x^{exponent - 1}'


# print(derive(7, 8))  # "56x^7"
# print(derive(5, 9))  # "45x^8"

# =========================================================================================================================

# ==========================================================================================================================
# Find the Integral
# =========================================================================================================================

'''Создайте функцию, которая находит интеграл от переданного выражения.

Чтобы найти интеграл, все, что вам нужно сделать, 
это добавить единицу к показателю степени (второй аргумент) 
и разделить коэффициент (первый аргумент) на это новое число.

Например, для 3x ^ 2 интеграл был бы равен 1x ^ 3: 
мы добавили 1 к показателю степени и разделили коэффициент на это новое число).

Записи:
Результатом должна быть строка.
Коэффициент и экспонента всегда являются целым положительным числом.

Примеры:
 3, 2  -->  "1x^3"
12, 5  -->  "2x^6"
20, 1  -->  "10x^2"
40, 3  -->  "10x^4"
90, 2  -->  "30x^3"

'''

# import codewars_test as test


# def integrate(coefficient, exponent):
#     return f'{int(coefficient / (exponent + 1))}x^{exponent+1}'


# @test.describe("Basic Tests")
# def basic_tests():
#     @test.it("Basic Tests")
#     def basic_tests():
#         test.assert_equals(integrate(3, 2), "1x^3")
#         test.assert_equals(integrate(12, 5), "2x^6")
#         test.assert_equals(integrate(20, 1), "10x^2")
#         test.assert_equals(integrate(40, 3), "10x^4")
#         test.assert_equals(integrate(90, 2), "30x^3")

# =========================================================================================================================

# ==========================================================================================================================
# Capitalization and Mutability
# =========================================================================================================================

"""Предполагалось, что ваш коллега напишет простую вспомогательную функцию 
для ввода заглавных букв в строку (содержащую одно слово) перед тем, как отправиться в отпуск.

К сожалению, сейчас они ушли, и код, который они вам дали, не работает. 
Исправьте вспомогательную функцию, которую они написали, 
так, чтобы она работала по назначению (т.е. сделайте первый символ в строке "word" заглавным).

Не беспокойтесь о числах, специальных символах или нестроковых типах, передаваемых в функцию.
 Длина строки будет составлять от 1 символа до 10 символов, но никогда не будет пустой.
"""
import codewars_test as test

# def capitalize_word(word):
#     return word.capitalize()


# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(capitalize_word('word'), 'Word')
#         test.assert_equals(capitalize_word('i'), 'I')
#         test.assert_equals(capitalize_word('glasswear'), 'Glasswear')


# =========================================================================================================================

# ==========================================================================================================================
# get character from ASCII Value
# =========================================================================================================================
"""
Напишите функцию get_char() / getChar(), 
которая принимает число и возвращает соответствующий символ ASCII для этого значения.
"""

# def get_char(c):
#     # Your code goes here ^_^
#     return chr(c)

#
# @test.it('Fixed tests')
# def _():
#     test.assert_equals(get_char(65), 'A')


# =========================================================================================================================

# ==========================================================================================================================
# Drink about
# =========================================================================================================================
"""
Дети пьют пунш.
Подростки пьют кока-колу.
Молодые люди пьют пиво.
Взрослые пьют виски.
Создайте функцию, которая получает возраст и возвращает то, что они пьют.

Дети в возрасте до 14 лет.
Подростки в возрасте до 18 лет.
Молодой человек в возрасте до 21 года.
У взрослых их 21 и более.
"""

# def people_with_age_drink(age):
# if age < 14:
#     return 'drink toddy'
# elif age >= 14 and age < 18:
#     return 'drink coke'
# elif age >= 18 and age < 21:
#     return 'drink beer'
# elif age >= 21:
#     return 'drink whisky'
''' Варианты решения
    if age > 20: return 'drink whisky'
    if age > 17: return 'drink beer'
    if age > 13: return 'drink coke'
    return 'drink toddy'''

# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it("should return 'drink toddy' when age is less than 14")
#     def _():
#         test.assert_equals(people_with_age_drink(13), 'drink toddy', "Wrong result for 13")
#         test.assert_equals(people_with_age_drink(0), 'drink toddy', "Wrong result for 0")

# @test.it("should return 'drink coke' when age is between 14(inclusive) and 18(exclusive)")
# def _():
#     test.assert_equals(people_with_age_drink(17), 'drink coke')
#     test.assert_equals(people_with_age_drink(15), 'drink coke')
#     test.assert_equals(people_with_age_drink(14), 'drink coke')

# @test.it("should return 'drink beer' when age is between 18(inclusive) and 21(exclusive)")
# def _():
#     test.assert_equals(people_with_age_drink(20), 'drink beer')
#     test.assert_equals(people_with_age_drink(18), 'drink beer')

# @test.it("should return 'drink whisky' when age is greater than or equal to 21")
# def _():
#     test.assert_equals(people_with_age_drink(22), 'drink whisky')
#     test.assert_equals(people_with_age_drink(21), 'drink whisky')


# =========================================================================================================================

# ==========================================================================================================================
# Reverse List Order
# =========================================================================================================================
""" В этом ката вы создадите функцию, 
которая принимает список и возвращает список в обратном порядке.
Примеры (Ввод -> Вывод)
* [1, 2, 3, 4] -> [4, 3, 2, 1]
* [9, 2, 0, 7] -> [7, 0, 2, 9]
"""

# def reverse_list(l):
#     return l[::-1]


# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(reverse_list([1, 2, 3, 4]), [4, 3, 2, 1])
#         test.assert_equals(reverse_list([3, 1, 5, 4]), [4, 5, 1, 3])
#         test.assert_equals(reverse_list([3, 6, 9, 2]), [2, 9, 6, 3])
#         test.assert_equals(reverse_list([1]), [1])


# =========================================================================================================================

# ==========================================================================================================================
# Triple Trouble
# =========================================================================================================================

'''Создайте функцию, которая будет возвращать строку, объединяющую все буквы трех введенных строк в группы. 
Берем первую букву всех входных данных и группируем их рядом друг с другом. 
Проделайте это для каждой буквы, смотрите пример ниже!

Например, ввод: "aa", "bb", "cc" => Вывод: "abcabc"'''

# def triple_trouble(one, two, three):
# your code here

# return ''.join(''.join(a) for a in zip(one, two, three))

# print(triple_trouble("aaa", "bbb", "ccc"))

# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(triple_trouble("aaa", "bbb", "ccc"), "abcabcabc")
#         test.assert_equals(triple_trouble("aaaaaa", "bbbbbb", "cccccc"), "abcabcabcabcabcabc")
#         test.assert_equals(triple_trouble("burn", "reds", "roll"), "brrueordlnsl")
#         test.assert_equals(triple_trouble("Bm", "aa", "tn"), "Batman")
#         test.assert_equals(triple_trouble("LLh", "euo", "xtr"), "LexLuthor")

# =========================================================================================================================

# ==========================================================================================================================
# Is he gonna survive?
# =========================================================================================================================

'''Герой находится на пути в замок, чтобы завершить свою миссию. 
Однако ему сказали, что замок окружен парой могущественных драконов! 
каждому дракону требуется по 2 пули, чтобы быть побежденным, наш герой понятия не имеет, 
сколько пуль у него должно быть с собой.. Предполагая, что он захватит определенное количество пуль и двинется вперед, 
чтобы сразиться с другим определенным количеством драконов, выживет ли он?

Верните true, если да, в противном случае false :)'''

# def hero(bullets: int, dragons: int) -> bool:
#     return bullets / 2 >= dragons


# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(hero(10, 5), True)
#         test.assert_equals(hero(7, 4), False)
#         test.assert_equals(hero(4, 5), False)
#         test.assert_equals(hero(100, 40), True)
#         test.assert_equals(hero(1500, 751), False)
#         test.assert_equals(hero(0, 1), False)

# =========================================================================================================================

# ==========================================================================================================================
# A Needle in the Haystack
# =========================================================================================================================

'''Можете ли вы найти иголку в стоге сена?

Напишите функцию findNeedle(), которая принимает массив, полный мусора, но содержащий одну "иглу".
После того, как ваша функция найдет иглу, она должна вернуть сообщение (в виде строки), в котором говорится:

"найдена игла в нужном положении" плюс индекс, по которому была найдена игла, так что:
'''

# def find_needle(haystack):
# your code here

# return f'found the needle at position {haystack.index("needle")}'


# @test.describe("Fixed Tests")
# def fixed_tests():
#     @test.it('Basic Test Cases')
#     def basic_test_cases():
#         test.assert_equals(find_needle(['3', '123124234', None, 'needle', 'world', 'hay', 2, '3', True, False]),
#                            'found the needle at position 3')
#         test.assert_equals(find_needle(
#             ['283497238987234', 'a dog', 'a cat', 'some random junk', 'a piece of hay', 'needle',
#              'something somebody lost a while ago']), 'found the needle at position 5')
#         test.assert_equals(find_needle(
#             [1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 5, 4, 3, 4, 5, 6, 67, 5, 5, 3, 3, 4, 2, 34, 234, 23, 4, 234, 324, 324,
#              'needle', 1, 2, 3, 4, 5, 5, 6, 5, 4, 32, 3, 45, 54]), 'found the needle at position 30')


# =========================================================================================================================

# ==========================================================================================================================
# Sentence Smash
# =========================================================================================================================

'''Напишите функцию, которая принимает массив слов, объединяет их в предложение и возвращает это предложение. 
Вы можете игнорировать любую необходимость в очистке слов или добавлении знаков препинания, 
но вы должны добавлять пробелы между каждым словом. Будьте осторожны, 
в начале или конце предложения не должно быть пробелов!'''

# def smash(words):

# return ' '.join(words)


# print(smash(["hello", "world"]))

# @test.describe("smash")
# def _():
#     @test.it("Should return empty string for empty array.")
#     def _():
#         test.assert_equals(smash([]), "")
#
#     @test.it("One word example should return the word.")
#     def _():
#         test.assert_equals(smash(["hello"]), "hello")
#
#     @test.it("Multiple words should be separated by spaces.")
#     def _():
#         test.assert_equals(smash(["hello", "world"]), "hello world")
#         test.assert_equals(smash(["hello", "amazing", "world"]), "hello amazing world")
#         test.assert_equals(smash(["this", "is", "a", "really", "long", "sentence"]), "this is a really long sentence")

# =========================================================================================================================

# ==========================================================================================================================
# Up and down, the string grows
# =========================================================================================================================

'''Многие языки программирования предоставляют функциональность преобразования строки в верхний или нижний регистр. 
Например, upcase/downcase в Ruby, upper/lower в Python и toUpperCase/toLowerCase в Java/JavaScript. 
Как правило, эти методы не изменяют размер строки.

Например, в Ruby значение str.upcase.downcase.size == str.size верно для большинства случаев.

Однако в некоторых особых случаях длина преобразованной строки может быть больше исходной. 
Можете ли вы найти строку, которая удовлетворяет этому критерию?

Вы должны просто установить значение STRANGE_STRING в соответствии с предыдущими критериями.

Примечание: Метапрограммирование в этом ката запрещено. Таким образом, размер вашего решения ограничен.
'''

# STRANGE_STRING = 'ß'


# @test.describe('Checking string length')
# def length_test():
#     up_and_down = STRANGE_STRING.upper().lower()
#     orig_len = len(STRANGE_STRING)
#     up_down_len = len(up_and_down)
#
#     @test.it('String length should grow' + f', actual length: {orig_len} ⇒ {up_down_len}' * (up_down_len > orig_len))
#     def _():
#         test.expect(up_down_len > orig_len, f'No grow, actual length: {orig_len} ⇒ {up_down_len}')
